package com.std.framework.innerrouter;

import com.google.auto.service.AutoService;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.TypeSpec;
import com.std.framework.annotation.RouterModule;
import com.std.framework.annotation.RouterPath;

import java.io.IOException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.Filer;
import javax.annotation.processing.Messager;
import javax.annotation.processing.ProcessingEnvironment;
import javax.annotation.processing.Processor;
import javax.annotation.processing.RoundEnvironment;
import javax.lang.model.element.Element;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.util.Elements;
import javax.lang.model.util.Types;

/**
 * Description:
 * Author: lixiao
 * Create on: 2018/10/8.
 * Job number:
 * Phone: 18611867932
 * Email: lixiao@chunyu.me
 */
@AutoService(Processor.class)
public class ChunyuProcessor extends AbstractProcessor {
    public static final String CLASS_DOC = "DO NOT EDIT THIS FILE ! THIS GENERATE BY CYROUTER";
    public static final String PACKAGE = "me.chunyu.lixiao.router";

    private Elements elementUtil;
    private Filer filer;
    private Messager messager;
    private Types typeUtil;

    private ClassName delegate = ClassName.get("com.std.framework.router", "MethodDelegate");
    private ClassName paramsWrapper = ClassName.get("com.std.framework.router", "ParamsWrapper");

    @Override
    public synchronized void init(ProcessingEnvironment processingEnvironment) {
        super.init(processingEnvironment);
        elementUtil = processingEnvironment.getElementUtils();
        filer = processingEnvironment.getFiler();
        messager = processingEnvironment.getMessager();
        typeUtil = processingEnvironment.getTypeUtils();
    }

    @Override
    public boolean process(Set<? extends TypeElement> set, RoundEnvironment roundEnvironment) {
        for (Element element : roundEnvironment.getElementsAnnotatedWith(RouterModule.class)) {
            List<Element> subColl = (List<Element>) element.getEnclosedElements();
            try {
                parseRouter(element, subColl).writeTo(filer);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return false;
    }

    private JavaFile parseRouter(Element module, List<Element> subElements) {
        RouterModule routerModule = module.getAnnotation(RouterModule.class);
        String schema = routerModule.schema();
        String host = routerModule.host();
        if (host == null || host.equals("")) {
            return null;
        }

        TypeSpec.Builder moduleBuilder = TypeSpec.classBuilder(schema + "$$" + host)
                .addModifiers(Modifier.PUBLIC,Modifier.FINAL)
                .addJavadoc(CLASS_DOC)
                .addField(Map.class, "mapping", Modifier.PRIVATE)
                .addField(Object.class, "origin", Modifier.PRIVATE);

        ClassName originClass = ClassName.get(elementUtil.getPackageOf(module).toString(), module.getSimpleName().toString());

        MethodSpec.Builder constructBuilder = MethodSpec.constructorBuilder()
                .addModifiers(Modifier.PUBLIC)
                .addStatement("this.origin= $T.class.newInstance()", originClass)
                .addStatement("this.mapping= new $T()", HashMap.class)
                .addException(Exception.class);

        int size = subElements.size();
        for (int i = 0; i < size; i++) {
            Element element = subElements.get(i);
            RouterPath routerPath = element.getAnnotation(RouterPath.class);
            if (routerPath == null) {
                continue;
            }
            String path = routerPath.value();
            String rawType = element.asType().toString();
            String formatType = rawType.substring(1, rawType.lastIndexOf(")"));
            String args = ((ExecutableElement) element).getParameters().toString();

            constructBuilder.addStatement(
                    "mapping.put($S + $T.METHOD, origin.getClass().getMethod($S" + getFullTypesString(formatType) + "))",
                    path,
                    delegate,
                    element.getSimpleName().toString());

            constructBuilder.addStatement("$T args$L=$S", String.class, i, args);
            constructBuilder.addStatement("mapping.put($S+$T.ARGS,$S)",
                    path,
                    delegate,
                    args
            );
            constructBuilder.addStatement("$T types$L=$S", String.class, i, formatType);
            constructBuilder.addStatement("mapping.put($S+$T.ARGS_TYPE,$S)",
                    path,
                    delegate,
                    formatType
            ).addCode("\n");
        }

        MethodSpec invokeMethod = MethodSpec.methodBuilder("invoke")
                .addModifiers(Modifier.PUBLIC,Modifier.FINAL)
                .returns(void.class)
                .addException(Exception.class)
                .addParameter(String.class, "path")
                .addParameter(paramsWrapper, "params")
                .addStatement("$T.invoke(path,mapping,origin,params)", delegate)
                .build();

        TypeSpec clazz = moduleBuilder
                .addMethod(constructBuilder.build())
                .addMethod(invokeMethod)
                .build();
        JavaFile javaFile = JavaFile.builder(PACKAGE, clazz)
                .build();
        return javaFile;
    }

    // "List<String>,List<String>,Map<String,String>" => "List.class,List.class"
    static String getFullTypesString(String agrsTypes) {
        if (agrsTypes == null || agrsTypes.length() == 0) {
            return "";
        }
        if (agrsTypes.contains(",")) {
            String[] arr = agrsTypes.split(",");
            StringBuilder builder = new StringBuilder();
            boolean mapAppear = false;
            for (String s : arr) {
                if (mapAppear) {
                    mapAppear = false;
                    continue;
                }
                if (s.contains("Map"))
                    mapAppear = true;
                builder.append(removeGeneric(s)).append(".class,");

            }
            String result = builder.toString();
            return "," + result.substring(0, result.length() - 1);
        } else {
            return "," + removeGeneric(agrsTypes) + ".class";
        }
    }

    // "List<String>" => "List"
    private static String removeGeneric(String argType) {
        int index = argType.indexOf("<");
        if (index != -1) {
            argType = argType.substring(0, index);
        }
        return argType;
    }

    @Override
    public Set<String> getSupportedAnnotationTypes() {
        Set<String> set = new HashSet<>();
        set.add(RouterModule.class.getCanonicalName());
        set.add(RouterPath.class.getCanonicalName());
        return set;
    }

}
